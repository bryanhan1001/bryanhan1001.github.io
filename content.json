{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-04-12T15:06:30.000Z","updated":"2021-11-17T14:49:47.021Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"学习笔记备忘"},{"title":"tags","date":"2021-11-17T14:45:48.000Z","updated":"2021-11-17T14:47:04.067Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"gopythonrust"}],"posts":[{"title":"rust学习笔记-function","slug":"rust学习笔记-function","date":"2021-11-17T14:17:16.000Z","updated":"2021-11-17T14:17:40.657Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738// fn another_function()&#123;// println!(&quot;another function&quot;);// &#125;// fn five() -&gt; i32 &#123;// 5// &#125;// fn plus_one(x:i32) -&gt; i32&#123;// x+1 // 该行如果加上分号，会变成语句，导致函数没有返回值，rust 默认返回一个空元组（），与定义的返回值类型不匹配// &#125;fn main() &#123; // println!(&quot;Hello, world!&quot;); // another_function(); // let x = five(); // println!(&quot;the value of x is：&#123;&#125;&quot;, x); // let y = plus_one(5); // println!(&quot;the value of y is: &#123;&#125;&quot;, y); // let number = 3; // if number &lt;5&#123; // println!(&quot;condition was true&quot;); // &#125; else &#123; // println!(&quot;condition was false&quot;); // &#125; // let condition = true; // let number = if condition &#123; // 5 // &#125; else &#123; // &quot;six&quot; // if 和 else 分支产生的值类型需要相同，因为变量只能拥有单一的类型，所以无法通过编译 // &#125;; // println!(&quot;the value of number is:&#123;&#125;&quot;, number)&#125;","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"rust学习笔记-string","slug":"rust学习笔记-string","date":"2021-11-17T14:16:05.000Z","updated":"2021-11-17T14:16:35.515Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 对于字符串字面量而言，将硬编码直接嵌入了最终可执行文件中，所以能够高效访问，// 但是我们不能将未知大小的文本编码在二进制文件中。对于String类型而言，为了支持一个可变的、可增长的文本类型，// 我们需要在堆上分配一块再编译时未知大小的内存来存放数据。这意味着：// 1. 我们使用的内存是由操作系统在运行时动态分配的// 2. 当使用完 String 时，我们需要通过某种方式来将这些内存归还给操作系统// =================================================================// rust 提供了另一套解决方案：内存会自动再拥有它的变量离开作用域后进行释放// rust 会在作用域结束的地方（`&#125;`）处自动调用 drop 函数，释放内存// =================================================================// 所有权规则// - rust中的每一个值都有一个对应的变量作为它的所有者// - 在同一时间内，值有且仅有一个所有者// - 当所有者离开自己的作用域，它持有的值就会被释放掉fn main() &#123; // let mut s = String::from(&quot;Hello&quot;); // 调用置于String命名空间下的 from 函数 // s.push_str(&quot;, world!&quot;); // push_str() 向String空间的尾部添加一段字面量 // println!(&quot;&#123;&#125;&quot;, s); // move， 默认类似于浅拷贝，但是会自动释放前一个变量 // let s1 = String::from(&quot;hello&quot;); // let _s2 = s1; // println!(&quot;&#123;&#125;, world!&quot;, s1) // 如果需要深度拷贝 String 堆上的数据，可以使用clone方法 // let s1 = String::from(&quot;hello&quot;); // let s2 = s1.clone(); // println!(&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;, s1, s2); // ================================================================= // rust 提供了一个名为 Copy 的 trait， 它可以用于整数这类完全存储在栈上的数据类型。 // 一旦某种类型拥有了 Copy 这种 trait，那么它的变量就可以在赋值给其他变量之后保持可用性 // 如果一种类型本身或这种类型的任意成员实现了 Drop 这种 trait，那么rust不允许其实现 Copy 这种 trait。 // 一般来说，任何简单标量的组合类型都可以是 Copy 的，任何需要分配内存或某种资源的类型都不会是 Copy 的，下面是一些拥有 Copy 的类型： // 1. 所有的中暑类型。诸如 u32 // 2. 仅拥有两种值的 bool类型 // 3. 字符类型（char） // 4. 浮点类型，f64 // 5. 如果一个元组的所有字段的类型都是可Copy的，那么这个元组也是可Copy的 // 把值传递给函数在语义上类似于对变量进行赋值，将变量传递给函数会触发移动或复制，就像是赋值语句一样。 // 变量所有权转移总是遵循相同的模式：将一个值复制给另一个变量时就会转移所有权。 // 当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。 // ================================================================= // 引用 &amp; 可以允许你在不获取所有权的前提下使用值， `*`操作成为解引用 // 与变量类似，引用是默认不可变的，rust 不允许我们去修改引用指向的值。 // 可变引用：&amp;mut String。可变引用是在使用上有一个很大的限制：对于特定作用域的特定数据，一次只能声明一个可变引用。这个限制可以帮助我们在编译时避免数据竞争。 // 与大部分语言类似，我们可以通过花括号来创建一个新的作用域，这就使我们可以创建多个可变引用。 // let mut s = String::from(&quot;hello&quot;); // &#123; // let r1 = &amp;mut s; // &#125; // let r2 = &amp;mut s; // ================================================================= // 在结合使用可变引用与不可变引用时，还有另外一条类似的限制规则，它会导致下面的代码编译失败： // 不能在拥有不可变引用的同时创建可变引用 // let mut s = String::from(&quot;hello&quot;); // let r1 = &amp;s; // let r2 = &amp;s; // let r3 = &amp;mut s; // println!(&quot;r1:&#123;&#125;, r2:&#123;&#125;, r3:&#123;&#125;&quot;, r1, r2, r3) // ================================================================= // 悬垂引用 // let reference_to_nothing = dangle(); // dangle() 内部创建的s，尝试返回一个指向s 的引用，rust会检测并拦截，解决方法可以直接返回 String，转移所有权到函数外部 // ================================================================= // 引用的规则： // 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。 // 引用总是有效的 // ================================================================= // 切片：除引用外，另一种不持有所有权的数据类型：切片允许我们引用集合中的某一段连续的元素序列。 let s1 = String::from(&quot;hello world&quot;); // println!(&quot;&#123;&#125;&quot;, first_word(&amp;s1)); println!(&quot;&#123;&#125;&quot;, first_word(&amp;s1[..])); // let s = String::from(&quot;hello world&quot;); // let hello = &amp;s[0..5]; // let world = &amp;s[6..11]; // println!(&quot;1:&#123;&#125;, 2:&#123;&#125;&quot;, hello, world); // ================================================================= // 借用规则： 当我们拥有了某个变量的不可变引用时，我们就无法同时获取改变量的可变引用。 // 字符串字面量就是切片。 // 这里变量 s 的类型就是 &amp;str：它是一个指向二进制程序特定位置的切片。正是由于 &amp;str 是一个不可变引用，所以字符串字面量才是不可变的 // let s = &quot;hello&quot;; // 其他类型的切片 // let s = [1,2,3,4,5]; // let slice = &amp;s[1..3]; // 总结： // 所有权、借用和切片的概念是 rust 可以在编译时保证内存安全的关键所在。像其他系统级语言一样，rust 给予了程序员完善的内存使用控制能力。 // 除此之外，借助于本章学习的工具，rust 还能自动清楚那些离开了作用域的数据。这几大地减轻了使用者的心智负担。&#125;// fn dangle() -&gt; &amp;String &#123;// let s = String::from(&quot;hello&quot;);// &amp;s// &#125;// fn no_dangle() -&gt; String &#123;// let s = String::from(&quot;hello&quot;);// s// &#125;// 返回第一个单词对应字符串的索引// fn first_word(s: &amp;String) -&gt; usize &#123;// let bytes = s.as_bytes(); // 把 String 转换成字节数组// for (i, &amp;item) in bytes.iter().enumerate()&#123;// if item == b&#x27; &#x27;&#123;// return i;// &#125;// &#125;// s.len()// &#125;// 函数签名 参数 &amp;String 改为 &amp;str，可以同时处理 String 和 &amp;str：fn first_word(s: &amp;str) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate()&#123; if item == b&#x27; &#x27;&#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125;","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"rust学习笔记-struct","slug":"rust学习笔记-struct","date":"2021-11-17T14:14:34.000Z","updated":"2021-11-17T14:15:39.850Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// 结构体是一种自定义的数据类型。它允许我们命名多个相关的值并将它们组成一个有机的结合体。// struct User &#123;// username: String,// email: String,// sign_in_count: u64,// active: bool,// &#125;// 可以和其他表达式一样，在函数体最后一个表达式中构造结构体实例，来隐式的将这个实例作为结果返回// fn build_user(email: String, username: String) -&gt; User &#123;// User &#123;// email,// username,// active: true,// sign_in_count: 1,// &#125;// &#125;fn main() &#123; // 结构体实例一旦可变，那么实例中所有字段都是可变的 // let mut user1 = User &#123; // email: String::from(&quot;someone@example.com&quot;), // username: String::from(&quot;someone123&quot;), // sign_in_count: 1, // active: true, // &#125;; // user1.email = String::from(&quot;anotheremail@example.com&quot;); // println!( // &quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, // user1.username, user1.email, user1.sign_in_count, user1.active // ); // 可以在不使用更新语法的前提下创建新的User实例 // let user2 = User&#123; // email: String::from(&quot;another@example.com&quot;), // username: String::from(&quot;anotherusername567&quot;), // sign_in_count: user1.sign_in_count, // active: user1.active, // &#125;; // let user2 = User &#123; // email: String::from(&quot;another@example.com&quot;), // username: String::from(&quot;anotherusername567&quot;), // ..user1 // &#125;; // println!( // &quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, // user2.username, user2.email, user2.sign_in_count, user2.active // ); // 使用不需要对字段命名的元组结构体来创建不同的类型 // struct Color(i32, i32, i32); // struct Point(i32, i32, i32); // let black = Color(0, 0, 0); // let origin = Point(0, 0, 0); // rust 允许我们创建没有任何字段的结构体。因为这种结构体与空元组（）十分相似，所以也被成为空结构体。 // 当你想在某些类型上实现一个trait，却不需要再改类型中存储任何数据时，空结构体可以发挥作用 // ================================================================ // 结构体所有权 // 我们希望结构体实例拥有自身全部数据的所有权，在这种情况下，只要结构体是有效的，那么它携带的数据也是有效的。 // 当然我们也可以在结构体中存储指向其他数据的引用，不过这需要用到 rust 中独有的生命周期功能。 // ================================================================ // let width1 = 30; // let height1 = 50; // println!( // &quot;the area of the rectangle is &#123;&#125; squrae pixels.&quot;, // area(width1, height1) // ); // area 函数将长和宽作为两个参数，但这两个参数要组合在一起才能定义一个长方形，下面用元组来重构 // let rect1 = (30, 50); // println!( // &quot;the area of the rectangle is &#123;&#125; squrae pixels.&quot;, // area(rect1) // ) // 元组传参，可能会混淆参数顺序，某些情况造成错误，下面用结构体重构 let rect = Rect &#123; width: 30, height: 50, &#125;; // println!(&quot;the area of the rectangle is &#123;&#125; squrae pixels.&quot;, area(&amp;rect)); // ================================================================ // 通过派生 trait 增加实用功能 println!(&quot;rect is &#123;:#?&#125;&quot;, rect); // ================================================================ // 定义方法 println!(&quot;the area of the rectangle is &#123;&#125; squrae pixels.&quot;, rect.area()); let rect2 = Rect &#123; width:10, height: 40 &#125;; let rect3 =Rect &#123; width:60, height:45 &#125;; println!(&quot;can rect1 hold rect2? &#123;&#125;&quot;, rect.can_hold(&amp;rect2)); println!(&quot;can rect1 hold rect3? &#123;&#125;&quot;, rect.can_hold(&amp;rect3)); // 关联函数：不用接收self作为参数的函数。常常被用作构造器返回一个结构体的新实例 // 调用方法如下： let sq = Rect::square(3); println!(&quot;&#123;:?&#125;&quot;, sq)&#125;// 使用 derive 注解来派生 trait，可以为自定义类型增加许多有用的功能#[derive(Debug)]struct Rect &#123; width: u32, height: u32,&#125;// fn area(width: u32, height: u32) -&gt; u32&#123;// width * height// &#125;// fn area(dimensions:(u32, u32)) -&gt; u32 &#123;// dimensions.0 * dimensions.1// &#125;// 使用结构体的不可变引用，因为我们希望借用结构体，而不是获取它的所有权// fn area(rect: &amp;Rect) -&gt; u32 &#123;// rect.width * rect.height// &#125;// 不需要获得数据的所有权，也不需要写入数据，所以使用借用即可。加入我们想在调用方法时改变实例的某些数据，那么第一个参数改为 &amp;mut self。// 通常来说，将第一个参数标记为self并在调用过程中去的所有权的方法并不常见。这种技术有可能被用于那些需要将self转换为其他类型，且在转换后想要阻止调用者访问原始实例的场景。impl Rect &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; fn can_hold(&amp;self, rect2:&amp;Rect) -&gt; bool &#123; self.width &gt; rect2.width &amp;&amp; self.height &gt; rect2.height &#125; fn square(size: u32) -&gt; Rect&#123; Rect &#123;width:size, height:size&#125; &#125;&#125;","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"rust学习笔记-变量","slug":"rust学习笔记-变量","date":"2021-11-17T14:12:51.000Z","updated":"2021-11-17T14:14:10.297Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041fn main() &#123; // let mut x = 5; // println!(&quot;The value of x is: &#123;&#125;&quot;, x); // x = 6; // println!(&quot;The value of x is: &#123;&#125;&quot;, x); // let x = 5; // let x = x + 1; // 变量隐藏 shadow // let x = x * 2; // println!(&quot;the value of x is: &#123;&#125;&quot;, x); // shadow 不同于 mut， 可以对这个值执行一系列的变换操作，并允许这个变量在操作后保持不可变 // 另一个区别在于：重复使用 let 会创建新变量，所以我们可以在不改变变量名称的同时改变其类型 // let spaces = &quot; &quot;; // let spaces = spaces.len(); // println!(&quot;spaces length is &#123;&#125;&quot;, spaces); // 复合类型 // 1. 元组类型：固定长度，可以存放不同类型值 // let tup:(i32, f64, u8) = (500, 6.4, 1); // 元组解构 // let (_, y, _) = tup; // println!(&quot;the value of y is: &#123;&#125;&quot;, y); // 可以使用(.)来访问元组的值 // let five_hundred = tup.0; // let six_point_four = tup.1; // let one = tup.2; // println!(&quot;the element of tup is: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, five_hundred, six_point_four, one) // 2. 数组类型 // 与元组不同的是，数组中的每一个元素都必须是相同的类型，rust 中的数组拥有固定的长度，一旦声明就不能随意改变大小。 // 当想在栈上分配空间时，数组是一个非常有用的工具 // rust 标准库提供了一个灵活的动态数组类型（vector），是一个类似于数组的集合解构，但它允许用户自由调整数组长度，类似go语言的数组和切片 let a:[i32; 5] = [1,2,3,4,5]; let first = a[0]; let second = a[1]; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, first, second)&#125;","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"}]},{"title":"golang面试题","slug":"golang面试题","date":"2021-04-13T14:46:45.000Z","updated":"2021-11-16T14:39:21.058Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"基本理解 Go 是传值还是传引用？ Go 面试官问我如何实现面向对象？ Go 结构体和结构体指针调用有什么区别吗？ Go new 和 make 是什么，差异在哪？ 什么是协程，协程和线程的区别和联系？ 调度模型 GMP 模型，为什么要有 P？ Go 结构体是否可以比较，为什么？ 单核 CPU，开两个 Goroutine，其中一个死循环，会怎么样？ 进程、线程都有 ID，为什么 Goroutine 没有 ID？ Goroutine 数量控制在多少合适，会影响 GC 和调度？ 详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？ Goroutine 泄露的情况有哪些？ Go 在什么时候会抢占 P？ 会诱发 Goroutine 挂起的 27 个原因 数据结构 Go interface 的一个 “坑” 及原理分析 Go defer 万恶的闭包问题 为什么 Go map 和 slice 是非线程安全的？ Go sync.map 和原生 map 谁的性能好，为什么？ 为什么 Go map 的负载因子是 6.5？ 摘自煎鱼大佬","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"}]},{"title":"python设计模式","slug":"python设计模式","date":"2021-04-12T14:47:25.000Z","updated":"2021-04-12T14:47:26.000Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"rust学习笔记","slug":"rust学习笔记","date":"2021-04-12T14:47:25.000Z","updated":"2021-11-16T14:40:50.191Z","comments":true,"path":"undefined/","link":"","permalink":"http://example.com/undefined/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://example.com/tags/rust/"},{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"}]}